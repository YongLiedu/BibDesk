Last update: 7 November 2007

The primary file type I expect is PDF, so much of the caching strategy and design is oriented towards PDF.  I'm not using NSImage or NSBitmapImageRep because performance was inadequate in my earlier trials (excessive memory consumption).  Of the two, NSBitmapImageRep had better drawing quality, particularly in view of the need to scale from small (< 48x48) to large (> 512x512) image sizes.  NSImage is too clever for its (and my) own good.

CGImageRef was the most flexible alternative to NSBitmapImageRep.  For drawing, I created the FVIcon abstract class, with a variety of concrete subclasses (all private to the framework), initialized based on UTI or sniffing.  The fallback is a QuickLook or Finder icon, depending on the platform.  The FVIcon has some provision for caching and explicitly flushing a cache; it's lazy about creating high-resolution images in order to keep memory requirements down.  In the simplest case, it's basically a wrapper around an NSURL instance and a CGImageRef.

Some of the grid layout concept was borrowed from MUPhotoView, particularly the idea of adjusting the grid in -drawRect: and limiting the degrees of freedom for the grid layout computation.  Unfortunately, MUPhotoView didn't scale for my needs, but was a good source of inspiration.

In the framework, private methods and ivars begin with a leading underscore so I can keep track of them more easily (this was really a huge help during development).  Apple seems to have backed off on the no-underscores-on-ivars requirement these days, and the private methods are named such that there's a low chance of collision (zero on 10.4--10.5).  NOTE: Private methods are generally private because they may have unintended side effects (some of the drawing methods assume that focus is locked and they can screw with the graphics state without saving/restoring, for instance, as an optimization).  I've tried to avoid One Big Method where the work can be factored out; this really helped with sanity in the drawing code, but it also implies that some methods are only called once.  This is intentional, since I find short blocks of code easier to figure out.  I've also tried to avoid multiple exit points and continue statements in loops, but a few have crept in.

Caching in FileView is moderately complicated, and uses heuristics that I've profiled on a dual G5 (1.8) and a PowerBook G4 (1.33), so performance should be adequate even on older hardware.  Not to say that performance couldn't be improved, or even that I haven't done something totally stupid here!

FileView expects an ordered list of NSURL instances, which may be file: scheme or other schemes (that was an afterthought, hence the name).  Some bindings support exists, mainly for optimized datasources.  However, FileView maintains its own cache mapping NSURL->FVIcon.  This works pretty well, since clients should not be expected to understand the internals or caching requirements.  However, it leads to some storage of redundant information.  In the worst case, a master detail view might have 1000 NSURLs that are each only touched once while the user scrolls through the master interface, yet FileView creates a cache entry for each of those.  To work around this, the cache is periodically checked against the datasource to reap "zombie" icons that no longer have a relationship to the datasource.  This is a fairly low-impact operation, providing the datasource is reasonably efficient.

Page-based FVIcon instances (PDF/PS/text) may use an on-disk cache (FVIconCache) for storing rendered CGImageRef data for fast reinitialization of large bitmaps.  This was a big performance win, especially for PDF files, where the bitmap data may be 14 MB of ARGB data.  These are never removed, so the cache can grow without bound.  Up to 500 PDF files, cache sizes are under 20 MB with the zlib compression I'm using, so I'm not too concerned about it.

FVIcon is designed to be thread safe, and still fairly lightweight.  Most drawing to offscreen bitmap contexts should be performed asynchronously in a thread, since rendering in the offscreen bitmap context will block.  If you need synchronous rendering, call the renderOffscreen method, wait until it's done, then draw the icon.  Some classes will draw a blank "page" while working in the thread; non page-based types don't do this.  The FVIconQueue handles all of this transparently, using a single thread shared amongst all FileView instances in an application.
